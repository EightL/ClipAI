<!doctype html><html><head><meta charset="utf-8" />
<title>ClipAI</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-f0mKkt1lEuzMdGII4XESyqCCpt5TR1+t0NenE2no0RvrRZtGJPD7W82dManIeZ9N" crossorigin="anonymous">
<!-- Markdown & KaTeX will be lazy-loaded on first render to keep initial memory low -->
	<style>
	html,body{margin:0;overflow:hidden}
	:root{--bg:#12161aee;--fg:#f1f5f9;--panel:#1c2228;--border:#253038;--panel-border:#2f3b44;--btn-bg:#222a31;--btn-border:#2f3b44;--btn-hover:#2b353d;--shadow:0 14px 38px -12px #000d;--accent:#4f9cff;--accent-fg:#ffffff}
	body.light{--bg:#ffffffee;--fg:#1b2733;--panel:#f5f8fa;--border:#d6dee4;--panel-border:#cfd8df;--btn-bg:#eef3f6;--btn-border:#d3dde3;--btn-hover:#e3eaef;--shadow:0 14px 32px -14px #0a15203a;--accent:#2563eb;--accent-fg:#ffffff}
	body.midnight{--bg:#0b0f17ee;--fg:#e4ecf5;--panel:#121926;--border:#1f2b3a;--panel-border:#1f2b3a;--btn-bg:#182233;--btn-border:#27354a;--btn-hover:#203146;--accent:#5b8fff;--accent-fg:#ffffff}
	body.forest{--bg:#0f1613ee;--fg:#e2f5ec;--panel:#16231d;--border:#1f3328;--panel-border:#1f3328;--btn-bg:#1b2d23;--btn-border:#254233;--btn-hover:#234a36;--accent:#34c482;--accent-fg:#042716}
	body.rose{--bg:#1c1014ee;--fg:#fde8ef;--panel:#26171d;--border:#3a222a;--panel-border:#3a222a;--btn-bg:#2d1c23;--btn-border:#442832;--btn-hover:#4c303b;--accent:#ff4f8b;--accent-fg:#2b0915}
	body.amber{--bg:#191307ee;--fg:#fff3d6;--panel:#241c0d;--border:#3a2b14;--panel-border:#3a2b14;--btn-bg:#2b210f;--btn-border:#423016;--btn-hover:#493719;--accent:#f4b21a;--accent-fg:#2a1900}
	body.contrast{--bg:#000000ee;--fg:#ffffff;--panel:#000;--border:#555;--panel-border:#555;--btn-bg:#0d0d0d;--btn-border:#555;--btn-hover:#222;--accent:#ffdd33;--accent-fg:#000}
	body{font:16px system-ui;background:transparent;color:var(--fg);-webkit-user-select:none;user-select:none;margin:0;padding:0;min-width:360px;max-width:1100px;-webkit-app-region:drag;position:relative;display:block}
	/* Outer wrapper carries shadow so its blur follows radius cleanly */
	#bubbleWrapper{position:relative;display:inline-block;border-radius:28px;box-shadow:var(--shadow);background:transparent;padding:0;margin:0}
	#bubble{position:relative;overflow:visible;white-space:normal;line-height:1.34;background:var(--panel);padding:18px 18px 20px 18px;border:none;border-radius:28px;font-size:16px;font-weight:500;display:inline-block;width:auto;max-width:860px;min-width:220px;box-sizing:border-box;-webkit-app-region:drag;color:var(--fg);-webkit-user-select:none;user-select:none;word-wrap:break-word}
	body.light #bubble,body.midnight #bubble,body.forest #bubble,body.rose #bubble,body.amber #bubble,body.contrast #bubble{background:var(--panel);color:var(--fg)}
	/* Preserve intentional newlines produced by postFormatMarkdown until markdown-it upgrades rendering */
	#bubbleContent{white-space:pre-line}
	button, .icon{cursor:pointer;background:var(--btn-bg);border:1px solid var(--btn-border);color:var(--fg);padding:7px 12px;font:500 14px system-ui;border-radius:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center;min-width:38px;transition:.18s background,color,border-color,box-shadow}
	button:hover,.icon:hover{box-shadow:0 2px 6px -2px #0008}
	button:active,.icon:active{background:var(--btn-hover);box-shadow:0 0 0 2px var(--panel) inset}
	button:hover,.icon:hover{background:var(--btn-hover);color:var(--fg)}
	#gear,#closeBtn{font-size:11px;height:20px;padding:1px 8px;position:absolute;top:6px;z-index:10;-webkit-app-region:no-drag;opacity:0;transition:opacity .15s, background .15s, color .15s;pointer-events:auto;display:flex;align-items:center;justify-content:center;border-radius:14px}
	#gear{right:6px}
	#closeBtn{left:6px}
	#bubble:hover #gear,#bubble:hover #closeBtn{opacity:1}
	#gear,#closeBtn{background:rgba(255,255,255,0.10);border:0}
	body.light #gear,body.light #closeBtn{background:rgba(0,0,0,0.06);border-color:#cfd8df}
	#gear:hover,#closeBtn:hover{background:var(--btn-hover)}
	#bubbleContent{-webkit-app-region:no-drag;user-select:text;-webkit-user-select:text;cursor:text}
	/* Remove unused legacy styles */
	::-webkit-scrollbar{width:6px}::-webkit-scrollbar-thumb{background:#444;border-radius:6px}
    </style></head><body>
	<div id="bubbleWrapper"><div id="bubble"><div class="icon" id="closeBtn" title="Close">✕</div><div class="icon" id="gear" title="Settings">⚙</div><span id="bubbleContent">Waiting for selection...</span></div></div>
<script>
	const bubble = document.getElementById('bubble');
	const bubbleContent = document.getElementById('bubbleContent');
	const gear = document.getElementById('gear');
	const closeBtn = document.getElementById('closeBtn');
	function formatCombo(e){
		let parts=[];
		if(e.metaKey) parts.push('Command');
		if(e.ctrlKey) parts.push('Control');
		if(e.altKey) parts.push('Alt');
		if(e.shiftKey) parts.push('Shift');
		let key = e.key;
		// Normalize common keys to Electron accelerator tokens
		if(key === ' ') key = 'Space';
		if(key === 'Escape') key = 'Esc';
		if(key.startsWith('Arrow')) key = key.replace('Arrow',''); // ArrowLeft -> Left
		if(/^F\d{1,2}$/.test(key)) { /* keep function key */ }
		else if(key.length===1){ key = key.toUpperCase(); }
		// Ignore if still a pure modifier
		if(['Control','Shift','Alt','Meta','Command'].includes(key)) return '';
		parts.push(key);
		return parts.join('+');
	}
	// --- State ---
	let lastClipboardText = '';
	let suppressResize = false; // prevent growth animation

	let lastSentW = 0, lastSentH = 0, adjustQueued = false, ignoring = false, lastAdjustTs = 0;
	const MIN_INTERVAL = 90; // ms between resize IPCs
	function adjustSize(force=false){
		if((suppressResize && !force) || ignoring) return;
		const now = performance.now();
		if(!force && (now - lastAdjustTs) < 30){ // coalesce very rapid bursts
			if(!adjustQueued){ setTimeout(()=> adjustSize(force), 28); }
			return;
		}
		if(adjustQueued) return;
		adjustQueued = true;
		requestAnimationFrame(()=>{
			adjustQueued = false;
			bubble.style.width = 'auto';
			const rect = bubble.getBoundingClientRect();
			const maxW = 860, minW = 220;
			let targetW = Math.round(Math.min(maxW, Math.max(minW, rect.width)));
			bubble.style.width = targetW + 'px';
			const targetH = Math.round(bubble.getBoundingClientRect().height);
			const wDiff = Math.abs(targetW - lastSentW);
			const hDiff = Math.abs(targetH - lastSentH);
			const since = performance.now() - lastAdjustTs;
			if(force || wDiff > 2 || hDiff > 2){
				if(force || since > MIN_INTERVAL){
					ignoring = true; // ignore ResizeObserver echoes briefly
					clipAI.resize(targetW, targetH);
					lastSentW = targetW; lastSentH = targetH; lastAdjustTs = performance.now();
					setTimeout(()=> ignoring = false, 80);
				}
			}
		});
	}
	new ResizeObserver(()=> adjustSize()).observe(document.body);
	// Gear now opens settings window
	gear.onclick = ()=> { clipAI.openSettings(); };
	closeBtn.onclick = ()=> { clipAI.hideWindow?.(); };
	let mdRenderer = null;
	let mdLoading = null;
	let markdownEnabled = true;
	// Lightweight text post-processor to coerce inline bullet output into proper lists
	function postFormatMarkdown(txt){
		if(!txt) return txt;
		// Count bullet markers
		const bulletMatches = txt.match(/\*\s+[A-Za-z]/g) || [];
		const hasNewlineBullets = /(\n\*\s)/.test(txt);
		// Case 1: inline bullets like '* Item one * Item two * Item three'
		if(!hasNewlineBullets && bulletMatches.length >= 2){
			// Strip leading bullet then split on subsequent bullet markers
			const cleaned = txt.replace(/^\s*\*\s+/,'');
			const rawItems = cleaned.split(/\s*\*\s+/).map(s=> s.trim()).filter(Boolean);
			const items = rawItems.map(i=>{
				// Bold leading label up to colon/dash if present
				return i.replace(/^([A-Z][A-Za-z0-9 ]{0,24})(?:\s*[:\-])\s+/,(m,label)=> `**${label}:** `);
			});
			return items.map(i=>'* '+i).join('\n');
		}
		// Case 2: bullets already multiline -> just ensure bold labels
		if(hasNewlineBullets){
			return txt.replace(/(^|\n)\*\s+([A-Z][A-Za-z0-9 ]{0,24})(:)(?=\s)/g,(m,pre,label,col)=> `${pre}* **${label}:**`);
		}
		// Case 3: labeled paragraphs without bullets -> convert if multiple labels
		const labelRegex = /(Problem|Approach|Outcome|Cause|Effect|Result|Summary)\s*:/gi;
		let labelCount=0; txt.replace(labelRegex,()=>{labelCount++; return '';});
		if(labelCount>=2){
			const converted = txt.replace(labelRegex,'\n* **$1:**').replace(/^\n+/,'');
			return converted;
		}
		return txt;
	}

	// Opportunistic early list -> HTML conversion before markdown-it is loaded (for instant feedback)
	function quickBulletHtml(txt){
		// Early convert simple inline asterisk bullet patterns before markdown-it loads
		// Accept either inline "* Item * Item" or already newline separated but markdown not yet parsed
		const bulletish = txt.match(/\*\s+[^*]/g)||[];
		if(bulletish.length>=2){
			const pf = postFormatMarkdown(txt);
			const lines = pf.split(/\n+/).map(l=>l.trim()).filter(Boolean);
			if(lines.length>=2 && lines.every(l=>/^\*\s+/.test(l))){
				return '<ul>'+ lines.map(l=>'<li>'+ basicInlineFormat( escapeHtml( l.replace(/^\*\s+/,'') ) ) +'</li>').join('') + '</ul>';
			}
		}
		return null;
	}
	// Minimal safe HTML escape
	function escapeHtml(s){ return s.replace(/[&<>]/g,c=> c==='&'?'&amp;':c==='<'?'&lt;':'&gt;'); }
	// Tiny inline markdown formatter (bold **, italic *, inline code `) for pre-markdown-it phase
	function basicInlineFormat(s){
		// Strong first to avoid conflicts; avoid matching across newlines
		// Use negative lookbehind for escaped asterisks (not exhaustive but lightweight)
		let out = s;
		// Bold **text**
		out = out.replace(/\*\*([^*\n][^\n]*?)\*\*/g,'<strong>$1</strong>');
		// Italic *text* (not preceded/followed by *)
		out = out.replace(/(^|\s)\*([^*\n][^\n]*?)\*(?=\s|[.,;!?)]|$)/g,(m,prefix,inner)=> prefix+'<em>'+inner+'</em>');
		// Inline code `code`
		out = out.replace(/`([^`\n]+)`/g,'<code>$1</code>');
		return out;
	}
	function loadScript(src){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=()=>res(); s.onerror=rej; document.head.appendChild(s); }); }
	// Lazy load markdown-it & katex only when first needed
	async function ensureMarkdown(){
		if(mdRenderer) return mdRenderer;
		if(mdLoading) return mdLoading;
		mdLoading = (async()=>{
			// Load markdown-it then katex plugin (katex CSS already in head)
			await loadScript('https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js');
			await loadScript('https://cdn.jsdelivr.net/npm/markdown-it-katex@2.0.3/dist/markdown-it-katex.min.js');
			if(window.markdownit){ mdRenderer = window.markdownit({html:false,linkify:true,breaks:true}).use(window.markdownitKatex); }
			return mdRenderer;
		})();
		return mdLoading;
	}
	// Render text quickly (plain -> optional quick bullets -> full markdown upgrade)
	async function setBubbleMarkdown(txt){
		// Render basic (plain/pre-line) text first, then upgrade to markdown list/formatting when ready
		const original = txt;
		if(markdownEnabled){
			const formatted = postFormatMarkdown(original);
			// show formatted text (with pre-line preserving breaks) immediately
			bubbleContent.textContent = formatted; // baseline safe text
			if(!mdRenderer){
				// attempt quick bullet conversion on formatted
				const quick = quickBulletHtml(formatted);
				if(quick){
					bubbleContent.innerHTML = quick;
				} else {
					// Fallback: apply inline formatting safely
					bubbleContent.innerHTML = basicInlineFormat(escapeHtml(formatted)).replace(/\n/g,'<br>');
				}
				ensureMarkdown().then(r=>{ if(r){ bubbleContent.innerHTML = r.render(formatted); adjustSize(); } });
			}else{
				bubbleContent.innerHTML = mdRenderer.render(formatted);
			}
		}else{
			bubbleContent.textContent = original;
		}
		if(!suppressResize) adjustSize();
	}
	// Main inbound result channel
	clipAI.onSummary(async d=>{ if(d.error){ bubbleContent.textContent='Error: '+d.error; } else { suppressResize=true; if(markdownEnabled){ setBubbleMarkdown(d.summary); } else { bubbleContent.textContent = d.summary; } }
		lastClipboardText = d.fullText || d.inputPreview || lastClipboardText || await clipAI.getClipboard();
		if(lastClipboardText) document.body.classList.add('compact');
		suppressResize=false; adjustSize(); });
	(async()=>{ const cfg = await clipAI.getConfig(); ['light','midnight','forest','rose','amber','contrast'].forEach(c=> document.body.classList.remove(c)); if(cfg.theme && cfg.theme!=='dark') document.body.classList.add(cfg.theme); markdownEnabled = cfg.markdownEnabled !== false; adjustSize(); })();
	// Theme change broadcast
	clipAI.onThemeChanged?.(t=>{ ['light','midnight','forest','rose','amber','contrast'].forEach(c=> document.body.classList.remove(c)); if(t && t!=='dark') document.body.classList.add(t); });
</script>
</body></html>
